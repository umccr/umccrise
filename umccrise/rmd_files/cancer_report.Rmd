---
author: "University of Melbourne Centre for Cancer Research"
date: "`r Sys.time()`"
output:
  html_document:
    theme: cosmo # darkly
    css: style.css
    toc: false
    code_download: true
  rmdformats::material:
    highlight: kate
params:
  title: "UMCCR Cancer Report"
  tumor_name: 'x'
  batch_name: 'x'
  genome_build: 'hg38'
  key_genes: 'x'
  af_global: 'x'
  af_keygenes: 'x'
  somatic_snv: 'x'
  somatic_sv: 'x'
  somatic_sv_vcf: 'x'
  purple_som_gene_cnv: 'x'
  purple_som_cnv: 'x'
  purple_germ_cnv: 'x'
  purple_purity: 'x'
  purple_qc: 'x'
  purple_som_snv_vcf: 'x'
  oncoviral_present_viruses: 'x'
  oncoviral_breakpoints_tsv: 'x'
  conda_list: 'x'
  result_outdir: 'x'
description: "Analysis of tumor/normal samples at UMCCR"
title: "`r paste(params$batch_name, params$title)`"
---

```{r knitr_opts, include=F}
knitr::opts_chunk$set(collapse = TRUE, echo = FALSE,
                      warning = FALSE, message = FALSE,
                      error = TRUE) # continue running report even after chunk errors
```

```{r render_report_interactively, echo=F, eval=FALSE}
genome_build <- "hg38"
batch_name <- "SBJ01025__SBJ01025_MDX210323_L2101149"
tumor_name <- "SBJ01025_MDX210323_L2101149"
# umccrised_dir <- "/g/data/gx8/projects/diakumis/umccrise/umccrise_dev/umccrised_SBJ01025"
# key_genes <- "/g/data/gx8/projects/diakumis/conda-dev/envs/umccrise/lib/python3.7/site-packages/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv"
umccrised_dir <- "./nogit/umccrised_data"
key_genes <- "./nogit/umccrised_data/umccr_cancer_genes.latest.tsv"

params <- list(
    tumor_name=                tumor_name,
    batch_name=                batch_name,
    genome_build=              genome_build,
    key_genes=                 key_genes,
    af_global=                 glue::glue("{umccrised_dir}/work/{batch_name}/cancer_report/afs/af_tumor.txt"),
    af_keygenes=               glue::glue("{umccrised_dir}/work/{batch_name}/cancer_report/afs/af_tumor_keygenes.txt"),
    somatic_snv=               glue::glue("{umccrised_dir}/{batch_name}/small_variants/{batch_name}-somatic-PASS.vcf.gz"),
    somatic_sv=                glue::glue("{umccrised_dir}/{batch_name}/structural/{batch_name}-manta.tsv"),
    somatic_sv_vcf=            glue::glue("{umccrised_dir}/{batch_name}/structural/{batch_name}-manta.vcf.gz"),
    purple_som_gene_cnv=       glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.cnv.gene.tsv"),
    purple_som_cnv=            glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.cnv.somatic.tsv"),
    purple_germ_cnv=           glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.cnv.germline.tsv"),
    purple_purity=             glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.purity.tsv"),
    purple_qc=                 glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.qc"),
    purple_som_snv_vcf=        glue::glue("{umccrised_dir}/work/{batch_name}/purple/{batch_name}.purple.somatic.vcf.gz"),
    oncoviral_present_viruses= glue::glue("{umccrised_dir}/work/{batch_name}/oncoviruses/present_viruses.txt"),
    oncoviral_breakpoints_tsv= glue::glue("{umccrised_dir}/work/{batch_name}/oncoviruses/oncoviral_breakpoints.tsv"),
    conda_list=                glue::glue("{umccrised_dir}/work/{batch_name}/conda_pkg_list.txt"),
    result_outdir=             glue::glue("{umccrised_dir}/{batch_name}/cancer_report_tables2")
)

render_me <- function() {
  rmarkdown::render(
    "cancer_report.Rmd",
    params = params)
}
render_me()
```

```{r load_pkgs}
# Bioconductor
library(BSgenome)
library(MutationalPatterns)
ref_genome <- paste0("BSgenome.Hsapiens.UCSC.", params$genome_build)
library(ref_genome, character.only = TRUE)
tx_ref_genome <- paste0("TxDb.Hsapiens.UCSC.", params$genome_build, ".knownGene")
library(tx_ref_genome, character.only = TRUE)
# CRAN
library(devtools)
library(details)
library(DT)
library(dplyr)
library(glue)
library(gt)
library(ggplot2)
library(htmltools)
library(jsonlite)
library(knitr)
library(kableExtra)
library(patchwork)
library(purrr)
library(readr)
library(rmarkdown)
library(stringr)
library(tidyr)
# umccr
library(gpgr)
```

```{r funcs}
bnm <- params$batch_name
img_dir <- file.path("img") # created when copying purple files to tmp dir
result_outdir <- params$result_outdir # directory to write tables to
blank_lines <- function(n = 10){cat(rep("&nbsp;  ",n), sep="\n")}

# get js indices when using in DT options
col_ind_js <- function(dt, col) {
  ntab <- setNames((1:ncol(dt) - 1), names(dt))
  stopifnot(all(col %in% names(dt)))
  sort(unname(ntab[col]))
}

# used in SV table Details
sv_detail_table <- function(tab) {
  # for checking if the columns in the dt are all described
  check_cols_described <- function(cols, descr) {
    stopifnot(is.character(cols), is.atomic(cols))
    stopifnot(is.character(descr), is.atomic(descr))
    for (col in cols) {
      if (!col %in% descr) {
        warning(glue::glue("{col} is not described!"))
      }
    }
  }

  check_cols_described(colnames(tab), sv_col_descr$Column)
  list(Column = colnames(tab)) %>%
    tibble::as_tibble() %>%
    dplyr::left_join(sv_col_descr, by = "Column") %>%
    knitr::kable()
}
```


```{r hrd_prep, results='hide'}
#---- Homologous Recombination Deficiency ----#
chord_sv_df <- gpgr::chord_mantavcf2df(params$somatic_sv_vcf)
chord_res <- gpgr::chord_run(
  vcf.snv = params$somatic_snv,
  df.sv = chord_sv_df,
  sv.caller = "manta",
  sample.name = params$tumor_name,
  ref.genome = params$genome_build,
  verbose = TRUE)

hrdetect_res <- NULL
# HRDetect doesn't handle empty files
if (gpgr::vcf_is_empty(params$somatic_sv_vcf) |
    gpgr::vcf_is_empty(params$somatic_snv)) {
  hrdetect_res <- tibble::tribble(
    ~sample, ~Probability, ~intercept, ~del.mh.prop, ~SNV3, ~SV3, ~SV5, ~hrd, ~SNV8,
    params$tumor_name, NA, NA, NA, NA, NA, NA, NA, NA
  )
} else {
  hrdetect_res <- gpgr::hrdetect_run(
    nm = params$tumor_name,
    snvindel_vcf = params$somatic_snv,
    sv_vcf = params$somatic_sv_vcf,
    cnv_tsv = params$purple_som_cnv,
    genome = params$genome_build,
    snvoutdir = tempdir())
}
```

```{r mutational_sigs_prep}
mutpat_gr <- MutationalPatterns::read_vcfs_as_granges(
  vcf_files = params$somatic_snv,
  sample_names = params$tumor_name,
  genome = ref_genome,
  group = "auto+sex",
  type = "all")

mp_snv <- gpgr::sig_count_snv(vcf_gr = mutpat_gr, ref_genome = ref_genome)
#mp_dbs <- gpgr::sig_count_dbs(vcf_gr = mutpat_gr)
mp_indel <- gpgr::sig_count_indel(vcf_gr = mutpat_gr, ref_genome = ref_genome)

mp_snv_plots <- gpgr::sig_plot_snv(gr_snv = mp_snv$gr_snv,
                                   snv_counts = mp_snv$snv_counts,
                                   ref_genome = ref_genome)
#mp_dbs_plots <- gpgr::sig_plot_dbs(dbs_counts = mp_dbs)
mp_indel_plots <- gpgr::sig_plot_indel(indel_counts = mp_indel)

sigs_snv_2015 <-
  gpgr::cosmic_signatures_2015 %>%
  gpgr::sig_contribution(mut_mat = mp_snv$snv_counts, signatures = .)
sigs_snv_2020 <-
  MutationalPatterns::get_known_signatures(muttype = "snv", incl_poss_artifacts = FALSE) %>%
  gpgr::sig_contribution(mut_mat = mp_snv$snv_counts, signatures = .)
#sigs_dbs <-
#  MutationalPatterns::get_known_signatures(muttype = "dbs") %>%
#  gpgr::sig_contribution(mut_mat = mp_dbs, signatures = .)
sigs_indel <-
  MutationalPatterns::get_known_signatures(muttype = "indel") %>%
  gpgr::sig_contribution(mut_mat = mp_indel, signatures = .)

gpgr::write_tsvjsongz(sigs_snv_2015, glue("sigs/{bnm}-snv_2015"), result_outdir)
gpgr::write_tsvjsongz(sigs_snv_2020, glue("sigs/{bnm}-snv_2020"), result_outdir)
#gpgr::write_tsvjsongz(sigs_dbs, glue("sigs/{bnm}-dbs"), result_outdir)
gpgr::write_tsvjsongz(sigs_indel, glue("sigs/{bnm}-indel"), result_outdir)
```

```{r sv_prep}
#---- Structural Variants ----#
sv_path <- params$somatic_sv
sv <- NULL
sv_unmelted <- NULL
sv_all <- NULL
no_sv_found <- TRUE
sv_tsv_descr <- NULL
sv_col_descr <- NULL
if (sv_path == "NA") {
  sv_unmelted <- tibble(WARNING = "Structural variants were not called")
  sv_all <- tibble(WARNING = "Structural variants were not called")
} else {
  no_sv_found <- gpgr::tsv_is_empty(sv_path)
  if (no_sv_found) {
    sv_unmelted <- tibble(WARNING = "THERE WERE 0 SVs PRIORITISED!")
    sv_all <- tibble(WARNING = "THERE WERE 0 SVs PRIORITISED!")
    sv_tsv_descr <- tibble(Column = "THERE WERE 0 SVs PRIORITISED!")
    sv_col_descr <- tibble(Column = "THERE WERE 0 SVs PRIORITISED!")
  } else {
    sv <- gpgr::process_sv(sv_path)
    sv_unmelted <- sv$unmelted
    sv_all <- sv$melted
    sv_tsv_descr <- sv$tsv_descr
    sv_col_descr <- sv$col_descr
  }
}

gpgr::write_tsvjsongz(sv_unmelted, glue("sv/{bnm}-01_sv_unmelted"), result_outdir)
gpgr::write_tsvjsongz(sv_all, glue("sv/{bnm}-02_sv_melted"), result_outdir)
```

```{r purple_prep}
#---- PURPLE QC Table ----#
purple_qc_summary <- dplyr::bind_rows(
  gpgr::purple_qc_read(params$purple_qc)[["summary"]] %>%
    dplyr::filter(!variable %in% c("Purity", "Gender")),
  gpgr::purple_purity_read(params$purple_purity)[["summary"]]
)

#---- PURPLE CNV Tables ----#
purple_cnv_som <- gpgr::purple_cnv_som_process(params$purple_som_cnv)
purple_cnv_som_gene <- gpgr::purple_cnv_som_gene_process(params$purple_som_gene_cnv, params$key_genes)
purple_cnv_germ <- gpgr::purple_cnv_germ_process(params$purple_germ_cnv)

gpgr::write_tsvjsongz(purple_cnv_som$tab, glue("purple/{bnm}-purple_cnv_som"), result_outdir)
gpgr::write_tsvjsongz(purple_cnv_som_gene$tab, glue("purple/{bnm}-purple_cnv_som_gene"), result_outdir)
gpgr::write_tsvjsongz(purple_cnv_germ$tab, glue("purple/{bnm}-purple_cnv_germ"), result_outdir)
```

```{r, results='asis'}
blank_lines(2)
```

## __Summary__

<details>
<summary>Description</summary>

PURPLE outputs a QC status along with a summary
for the inferred purity and ploidy of the somatic sample.
The 'QC Status' field reflects how we have determined the purity of the sample.
A 'FAIL' or 'WARN' QC status can be attributed to several factors:

* `FAIL_CONTAMINATION`: measured contamination in the tumor (by Amber) is >10%
* `FAIL_NO_TUMOR`: no evidence of tumor is found in the sample, when all
  following criteria are satisfied:
  - tumor has one or more HOTSPOT SV or point mutation
  - SNV sum(allele read count) > 5000
  - SV sum(startTumorVariantFragmentSupport) > 1000 (excluding SGL breakends)
* `WARN_DELETED_GENES`: more than 280 homozygously deleted genes.
  This sometimes occurs in samples with very high MB scale GC bias, and
  particularly affects high GC content regions such as CHR 19.
  It may also indicate a poor fit.
* `WARN_HIGH_COPY_NUMBER_NOISE`: more than 220 copy number segments __not__
  supported at either end by SV breakpoints.
  Indicates samples with extreme GC bias, with differences
  in depth of >= 10x between high and low GC regions. GC normalisation is
  unreliable when the corrections are so extreme so it is recommended to fail
  the sample (concerns with miscalled deletions or amplifications or have
  poor sensitivity in high GC regions).
* `WARN_GENDER_MISMATCH`: if the AMBER and COBALT inferred genders are
  inconsistent then the COBALT one is used but the sample is failed.
* `WARN_LOW_PURITY`: fitted purity < 20%

</details>


```{r summary_tables}
summarise_sigs <- function(mut_sig_contr) {
  mut_sig_contr %>%
    head(2) %>%
    dplyr::mutate(string = paste0(Signature, " (", Contribution, " - ", RelFreq, ")")) %>%
    dplyr::pull(string) %>%
    paste(collapse = ", ")
}

hrd_summary <- list(chord = chord_res[["prediction"]][, "p_hrd", drop = TRUE],
                    hrdetect = hrdetect_res[, "Probability", drop = TRUE])

cnv_summary <-
  list(som = purple_cnv_som$tab, germ = purple_cnv_germ$tab) %>%
  purrr::map(~ dplyr::summarise(
    .x,
    Min = round(min(CN), 2),
    Max = round(max(CN), 2),
    N = dplyr::n(), .groups = "drop_last"))

if (no_sv_found) {
  sv_summary <- tibble(unmelted = c(0), melted = c(0))
} else {
  sv_summary <-
    list(unmelted = sv_unmelted %>% dplyr::select(Type),
         melted = sv_all %>% dplyr::select(Type)) %>%
    purrr::map(function(x) addmargins(table(x, useNA = 'ifany'))) %>%
    do.call("rbind", .) %>%
    as.data.frame() %>%
    tibble::rownames_to_column(var = "group") %>%
    tidyr::pivot_longer(-group) %>%
    dplyr::mutate(value = paste0(name, ": ", value)) %>%
    tidyr::pivot_wider(names_from = group, values_from = value) %>%
    dplyr::select(unmelted, melted)
}

qc_summary_all <- dplyr::tribble(
  ~n, ~variable, ~value, ~details,
  5, "MutSigs (Old)", glue::glue("{summarise_sigs(sigs_snv_2015)}"),
  "2015 COSMIC (https://cancer.sanger.ac.uk/cosmic/signatures_v2.tt)",
  5, "MutSigs (New)", glue::glue("{summarise_sigs(sigs_snv_2020)}"),
  "2020 COSMIC (https://cancer.sanger.ac.uk/cosmic/signatures)",
  6, "HRD", glue::glue("CHORD: {hrd_summary$chord}; HRDetect: {hrd_summary$hrdetect}"),
  "Homologous recombination deficiency probability.",
  20, "CNVs (Somatic)", glue::glue("Min: {cnv_summary[['som']]$Min}; ",
                                   "Max: {cnv_summary[['som']]$Max}; ",
                                   "N: {cnv_summary[['som']]$N} "), "",
  21, "CNVs (Germline)", glue::glue("Min: {cnv_summary[['germ']]$Min}; ",
                                   "Max: {cnv_summary[['germ']]$Max}; ",
                                   "N: {cnv_summary[['germ']]$N} "), "",
  18, "SVs (unmelted)", paste(rev(sv_summary$unmelted), collapse = ", "),
  "Summary of SVs as presented in raw VCF.",
  19, "SVs (melted)", paste(rev(sv_summary$melted), collapse = ", "),
  "Summary of SVs after splitting annotations for each event into a separate variant row.",
  22, "Genome", params$genome_build, "Human genome assembly used."
) %>%
  dplyr::bind_rows(
    purple_qc_summary
  ) %>%
  dplyr::arrange(n) %>%
  dplyr::select(-n)

qc_summary_all %>%
  gt::gt(rowname_col = "variable") %>%
  gt::tab_style(
    style = list(
      cell_fill(color = "#FF4646"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = vars(value),
      rows = grepl("FAIL", value) & variable == "QC_Status")) %>%
  gt::tab_style(
    style = list(
      cell_fill(color = "#FED8B1"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = vars(value),
      rows = grepl("WARN_", value) & variable == "QC_Status")) %>%
  gt::tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = list(cells_stub(rows = TRUE),
                     cells_body(columns = vars(value)))
  ) %>%
  gt::cols_align("left") %>%
  gt::opt_row_striping() %>%
  gt::tab_options(table.align = "left")

gpgr::write_tsvjsongz(qc_summary_all, glue("{bnm}-qc_summary"), result_outdir)
```

```{r, results='asis'}
blank_lines(1)
```

## __Somatic Mutation Profiles__

```{r, results='asis'}
blank_lines(1)
```

### __Allelic Frequencies__ {#allelic-freqs}
Summarised below are the allele frequencies (AFs) for somatic variants detected
genome-wide (__Global__) vs. within the coding sequence of ~1,100 UMCCR
cancer genes (__Key Genes CDS__).
AFs range from 0 to 1, or 0%-100% (we filter out all novel variants with AF < 10%).

<details>
<summary>Details</summary>

Variants are typically called in bcbio by 3 different callers, with calls supported by at least 2 of them used ("ensemble" approach).
In some cases only a single caller is used due to technical reasons (e.g. highly mutated FFPE sample).

The following post-processing steps occur:

1. `somatic_vcf_annotate`: [annotate VCF](https://github.com/umccr/vcf_stuff/blob/master/vcf_stuff/filtering/annotate_somatic_vcf.smk)
    against databases of known hotspots, germline variants, low mappability regions, UMCCR panel of normals
2. `somatic_vcf_filter`: [filter VCF](https://github.com/umccr/vcf_stuff/blob/master/scripts/filter_somatic_vcf)
    to remove germline variants and artefacts, but keep known hotspots
3. As preparation for the allelic frequencies plots:
    * `subset_to_giab`: keep variants in 'high confidence' regions as determined by the [Genome in a Bottle consortium](http://jimb.stanford.edu/giab/)
    * keep only variants with AF above 10%
4. Allele frequencies for global and keygenes:
    * `afs`: grab only the `INFO/TUMOR_AF` field and output to final txt file
    * `afs_keygenes`: grab the `CHROM`, `POS`, `ID`, `REF`, `ALT` and `INFO/TUMOR_AF`
      for variants in the UMCCR cancer gene BED file, and output to final txt file
</details>


```{r allele_freq_stats}
af_summary_results <- gpgr::af_summary(params$af_global, params$af_keygenes)
af_summary_results$af_stats_gt
```

```{r, results='asis'}
blank_lines(1)
```

```{r allele_freq_plot, fig.width=10, fig.height=3}
af_summary_results$af_plot
```

```{r, results='asis'}
blank_lines(1)
```

### __SNV__ Signatures {.tabset .tabset-fade #sig-snv}

Deciphering the mutational signature of a tumor sample can provide insight into the mutational
processes involved in carcinogenesis and help in cancer treatment and prevention.
The [MutationalPatterns](http://bioconductor.org/packages/release/bioc/html/MutationalPatterns.html)
R package is used to generate a mutation signature for the sample. We use the final filtered somatic
calls as input.

#### Characteristics

<details>
<summary>Description</summary>

See [MutationalPatterns SNV Characteristics](http://bioconductor.org/packages/release/bioc/vignettes/MutationalPatterns/inst/doc/Introduction_to_MutationalPatterns.html#snvs).

</details>


```{r mp_snv_plots, out.width="90%", fig.width=18, fig.height = 10}
(mp_snv_plots$p_river / mp_snv_plots$p_heatmap) |
  (mp_snv_plots$p_spectrum / mp_snv_plots$p_96_profile)
```

#### Strand Bias

<details>
<summary>Description</summary>

See [MutationalPatterns Strand Bias Analysis](http://bioconductor.org/packages/release/bioc/vignettes/MutationalPatterns/inst/doc/Introduction_to_MutationalPatterns.html#strand-bias-analyses).

</details>

```{r mutationalpatterns_strand_bias, fig.width=7, fig.height=7}
## ---- Transcriptional ---- ##
# Get known genes table from UCSC
genes_list <- GenomicFeatures::genes(base::get(tx_ref_genome))

# Mutation count matrix with strand info (4*6*4=96 -> 96*2=192)
mutpat_gr_snv <- MutationalPatterns::get_mut_type(mutpat_gr, type = "snv")
mut_mat_s <- MutationalPatterns::mut_matrix_stranded(vcf_list = mutpat_gr_snv,
                                                     ref_genome = ref_genome,
                                                     ranges = genes_list,
                                                     mode = "transcription")

# Mutation count per type and strand
strand_counts <- MutationalPatterns::strand_occurrences(mut_mat_s, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias <- MutationalPatterns::strand_bias_test(strand_counts)

# mutation spectrum with strand distinction
mp_plot_bias1 <- MutationalPatterns::plot_strand(strand_counts, mode = "relative") +
  ggplot2::ggtitle("Transcriptional Strand Bias")
# effect size of strand bias
mp_plot_bias2 <- MutationalPatterns::plot_strand_bias(strand_bias)


## ---- Replicative ---- ##

repli_file <- system.file("extdata/ReplicationDirectionRegions.bed",
                          package = "MutationalPatterns")
# start/stop contain scientific notation, so need to be doubles
repli_strand <-
  readr::read_tsv(repli_file, col_names = TRUE, col_types = "cddcc") %>%
  dplyr::mutate_if(is.character, as.factor)
repli_strand_granges <- GenomicRanges::GRanges(
  seqnames = repli_strand$Chr,
  ranges = IRanges::IRanges(start = repli_strand$Start + 1,
                   end = repli_strand$Stop),
  strand_info = repli_strand$Class)

GenomeInfoDb::seqlevelsStyle(repli_strand_granges) <- GenomeInfoDb::seqlevelsStyle(base::get(ref_genome))

mut_mat_s_rep <-
  MutationalPatterns::mut_matrix_stranded(
    vcf_list = mutpat_gr_snv,
    ref_genome = ref_genome,
    ranges = repli_strand_granges,
    mode = "replication")
# Mutation count per type and strand
strand_counts_rep <- MutationalPatterns::strand_occurrences(mut_mat_s_rep, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias_rep <- MutationalPatterns::strand_bias_test(strand_counts_rep)

mp_plot_bias3 <- MutationalPatterns::plot_strand(strand_counts_rep, mode = "relative") +
  ggplot2::ggtitle("Replicative Strand Bias")
mp_plot_bias4 <- MutationalPatterns::plot_strand_bias(strand_bias_rep)


(mp_plot_bias1 / mp_plot_bias2) | (mp_plot_bias3 / mp_plot_bias4)
```

```{r, results='asis'}
blank_lines(1)
```

### __SNV__ Signature Contribution {.tabset .tabset-fade #sig-snv-contr}

<details>
<summary>Description</summary>

The contribution of any set of signatures to the mutational profile of a
sample can be quantified. This unique feature is specifically useful
for mutational signature analyses of small cohorts or individual samples,
but also to relate own findings to known signatures and published findings.
The `fit_to_signatures` function finds the optimal linear combination of
mutational signatures that most closely reconstructs
the mutation matrix by solving a non-negative least-squares constraints problem.

Shown are signatures with positive Contribution values, along with summarised descriptions
and reference signature plots from <https://cancer.sanger.ac.uk/cosmic/signatures>.

</details>

```{r, results='asis'}
blank_lines(1)
```

#### 2015

```{r sig_snv_2015_contr}
sigs_snv_2015 %>%
  gpgr::sig_contribution_table(type = "Sig", outdir = img_dir) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling(c("hover", "striped"), font_size = 12) %>%
  kableExtra::scroll_box(height = "400px")
```

```{r, results='asis'}
blank_lines(1)
```

#### 2020

```{r sig_snv_2020_contr}
sigs_snv_2020 %>%
  gpgr::sig_contribution_table(type = "SBS", outdir = img_dir) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(c("hover", "striped"), font_size = 12) %>%
  kableExtra::scroll_box(height = "400px")
```

```{r, results='asis'}
blank_lines(1)
```

### __INDEL/DBS__ Signatures & Contributions {.tabset .tabset-fade #sig-indeldbs}

<details>
<summary>Description</summary>

See [MutationalPatterns INDEL/DBS Characteristics](http://bioconductor.org/packages/release/bioc/vignettes/MutationalPatterns/inst/doc/Introduction_to_MutationalPatterns.html#indels).

</details>


#### INDEL

```{r mp_indel_plots_contr, out.width="90%", fig.width=14}
mp_indel_plots$p_indel_main | mp_indel_plots$p_indel_cont
sigs_indel %>%
  gpgr::sig_contribution_table(type = "ID", outdir = img_dir) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(c("hover", "striped"), font_size = 12) %>%
  kableExtra::scroll_box(height = "400px")
```

```{r, results='asis'}
blank_lines(1)
```

#### DBS

**DISABLED UNTIL https://github.com/umccr/umccrise/issues/59 IS RESOLVED**

```{r mp_dbs_plots_contr, out.width="90%", fig.width=14, eval=FALSE}
mp_dbs_plots$p_dbs_main | mp_dbs_plots$p_dbs_cont
sigs_dbs %>%
  gpgr::sig_contribution_table(type = "DBS", outdir = img_dir) %>%
  knitr::kable() %>%
  kableExtra::kable_styling(c("hover", "striped"), font_size = 12) %>%
  kableExtra::scroll_box(height = "400px")
```

```{r, results='asis'}
blank_lines(1)
```

### __Rainfall Plot__ {#rainfall}
Rainfall plots show the distribution of mutations along the genome, with mutation types
indicated with different colors. The y-axis corresponds to the distance of a mutation from the
previous mutation, and is log10 transformed. Drop-downs from the plots indicate clusters or
"hotspots" of mutations.

```{r mutationalpatterns_rainfall, out.width="90%", fig.width=14}
# When there is only 1 or lower number of variants on a chromosome,
# MutationalPatterns::plot_rainfall will crash with an error. So need to check if it will work beforehand.
chromosomes <- GenomeInfoDb::seqnames(base::get(ref_genome))[1:22]
vcf <- mutpat_gr_snv[[1]]
chr_subset <- vcf[GenomeInfoDb::seqnames(vcf) == chromosomes[1]]
n <- length(chr_subset)
will_work <- FALSE
for (i in 1:length(chromosomes)) {
  chr_subset <- vcf[GenomeInfoDb::seqnames(vcf) == chromosomes[i]]
  n <- length(chr_subset)
  if (n >= 2) {
    will_work <- TRUE
  }
}
if (will_work) {
  MutationalPatterns::plot_rainfall(vcf,
                                    chromosomes = GenomeInfoDb::seqnames(base::get(ref_genome))[1:22],
                                    cex = 1.2, ylim = 1e+09)
}
```

### __Kataegis__
Somatic variants of type C>T and C>G in a TpCpN context are annotated as
showing Kataegis (Nik Zainal et al., 2012) if there are three or more
mutations of that type, strand and context localised within a
region with an average inter-mutation distance of <= 1kb.
The annotation describes the strand it was found on
along with an ID that is shared by grouped variants.

```{r purple_kataegis_table}
kat <- gpgr::purple_kataegis(params$purple_som_snv_vcf)
details::details(knitr::kable(kat$description), lang = NULL, summary = "Column Description")
if (nrow(kat$data) > 0) {
  DT::datatable(kat$data, filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(
                  scroller = TRUE, scrollY = 200, scrollX = TRUE, autoWidth = FALSE, keys = TRUE,
                  buttons = c('csv', 'excel'), dom = 'Blfrtip'))
} else {
  cat("No kataegis regions detected.")
}
```

```{r purple_plot_somaticrainfall, out.width="70%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.somatic.rainfall.png')))
```

```{r, results='asis'}
blank_lines(1)
```

## __HRD (Homologous Recombination Deficiency) Detection__ {#hrd}

<details>
<summary>Description</summary>

__CHORD__

For more details see <https://github.com/UMCUGenetics/CHORD>.

__Probabilities__

CHORD outputs the probability of:

* HRD: `p_hrd`
* BRCA1-type HRD: `p_BRCA1`
* BRCA2-type HRD: `p_BRCA2`

__HR status and type__

`hr_status` tells us if a sample is HR deficient (`p_hrd >= 0.5`) or proficient.
If a sample is HRD, then `hrd_type` will tell us if the sample has BRCA1-type HRD
or BRCA2-type HRD (=`max(p_BRCA1, p_BRCA2)`).

__Pre-requisites for accurate HRD prediction__

* CHORD requires `>=50` indels to accurately determine whether a sample is HRD

If this criterion is not met, `hr_status` will be `cannot_be_determined` and `remarks_hr_status` will be
`<50 indels`.

* CHORD cannot be applied to MSI samples

If an MSI sample is detected, `hr_status` will be `cannot_be_determined` and `remarks_hr_status` will be
`Has MSI (>14000 indel.rep)`.

* If a sample is HRD, CHORD requires `>=30` SVs to accurately determine HRD subtype

If this criterion is not met, `hrd_type` will be `cannot_be_determined`, and `remarks_hr_status` will be `<30 SVs`.

The user may of course ignore these remarks and proceed with using the raw probabilities output by CHORD
(`p_hrd` and/or `p_BRCA1/pBRCA2`).

__HRDetect__

See https://github.com/Nik-Zainal-Group/signature.tools.lib for the R package
that includes HRDetect.

</details>

```{r chord_hrdetect_res}
hrd_results <- gpgr::hrd_results_tabs(hrdetect_res, chord_res)
gpgr::write_tsvjsongz(chord_res[["prediction"]], glue("hrd/{bnm}-chord"), result_outdir)
gpgr::write_tsvjsongz(hrdetect_res, glue("hrd/{bnm}-hrdetect"), result_outdir)
hrd_results$hrd_results_gt
```

```{r, results='asis'}
blank_lines(1)
```

## __Circos Plots__ {.tabset .tabset-fade #circos}
Circos plots are generated by PURPLE.
The first BAF plot is based on PURPLE data and configuration files.

### BAF, Total/Minor CN, SVs

<details>
<summary>Description</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: <span style="color:#8A2BE2">Beta Allele Frequency</span>.
  Given that the BAF points correspond to allele frequencies of heterozygous SNPs that are common in germline samples,
  there shouldn't be any in chromosome Y (and chromosome X when male).
* __Track3__: __Total__ copy number changes adjusted for tumor purity,
  including focal and chromosomal somatic events.
  <span style="color:red">Red</span> = Loss; <span style="color:#32CD32">Green</span> = Gain.
  Scaled from 0 (complete loss) to 6 (high level gains).
  If > 6, shown as 6 with a green dot on the outermost green gridline.
* __Track4__: __Minor__ allele copy numbers. Range from 0 to 3.
  Expected normal minor allele copy number is 1, and anything below 1 is shown
  as a loss (<span style="color:#EE7600">Orange</span>), representing an LOH event.
  Minor allele copy numbers above 1 (<span style="color:#7EC0EE">Blue</span>) indicate gains
  of both A and B alleles.
* __Track5__ (Inner circle): Observed structural variants within or between the chromosomes.
    * <span style="color:#7EC0EE">Blue</span> = Translocations
    * <span style="color:red">Red</span> = Deletions
    * <span style="color:#e6e600">Yellow</span> = Insertions
    * <span style="color:#32CD32">Green</span> = Tandem duplications
    * <span style="color:#000000">Black</span> = Inversions

</details>

```{r circos_baf_plot, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.circos_baf.png')))
```


### SNVs/Indels, Total/Minor CN, SVs

<details>
<summary>Description</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: Somatic variants (incl. exon, intron and intergenic regions).
    * outer ring: SNP allele frequencies, corrected for tumor purity and scaled from 0 to 100%.
      Each dot represents a single somatic variant, coloured according to the
      type of base change (e.g. C>T/G>A in red).
    * inner ring: short insertion (yellow) and deletion (red) locations.
* __Track3__: Observed __total__ copy number changes adjusted for tumor purity,
  including focal and chromosomal somatic events.
  <span style="color:red">Red</span> = Loss; <span style="color:#32CD32">Green</span> = Gain.
  Scaled from 0 (complete loss) to 6 (high level gains).
  If > 6, shown as 6 with a green dot on the outermost green gridline.
* __Track4__: Observed __minor__ allele copy numbers. Range from 0 to 3.
  Expected normal minor allele copy number is 1, and anything below 1 is shown
  as a loss (<span style="color:#EE7600">Orange</span>), representing an LOH event.
  Minor allele copy numbers above 1 (<span style="color:#7EC0EE">Blue</span>) indicate gains
  of both A and B alleles.
* __Track5__ (Inner circle): Observed structural variants within or between the chromosomes.
    * <span style="color:#7EC0EE">Blue</span> = Translocations
    * <span style="color:red">Red</span> = Deletions
    * <span style="color:#e6e600">Yellow</span> = Insertions
    * <span style="color:#32CD32">Green</span> = Tandem duplications
    * <span style="color:#000000">Black</span> = Inversions

</details>

```{r circos_default1, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.circos.png')))
```

### Allele Ratios, BAF

<details>
<summary>Description</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: <span style="color:blue">Tumor</span> and <span style="color:#32CD32">Normal</span> Allele Ratios
* __Track3__: <span style="color:#EE7600">Beta Allele Frequency</span>
  Given that the BAF points correspond to allele frequencies of heterozygous SNPs that are common in germline samples,
  there shouldn't be any in chromosome Y (and chromosome X when male).

</details>

```{r circos_default2, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.input.png')))
```

## __Structural Variants__ {#sv-summary}
Structural variants are inferred with [Manta](https://github.com/illumina/manta),
adjusted using [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator#7-structural-variant-recovery-and-single-breakend-filtering),
and prioritised using [simple_sv_annotation](https://github.com/AstraZeneca-NGS/simple_sv_annotation).
Allele frequencies, copy number changes and ploidy are purity-adjusted.

<details>
<summary>SV Prioritisation Process</summary>

The input file corresponds to `umccrised/<batch>/structural/<batch>-manta.tsv`.

It's generated through the following steps:

__Step 1: Processing__

* __Input__: Manta structural variant calls from bcbio
(`final/<tumor-name>/<batch-name>-sv-prioritize-manta.vcf.gz` (or
`<batch-name>-manta.vcf.gz` if not prioritised))
* Remove following annotations from Manta VCF:
  'INFO/SIMPLE_ANN', 'INFO/SV_HIGHEST_TIER', 'FILTER/Intergenic', 'FILTER/MissingAnn', 'FILTER/REJECT'
* Prioritise variants with [simple_sv_annotation](https://github.com/vladsaveliev/simple_sv_annotation)`
* __Output__: `work/{batch}/structural/prioritize/{batch}-manta.vcf.gz`
* Keep PASS variants
* If more than 100,000 variants, keep only variants where `INFO/SV_TOP_TIER <= 3`
* __Output__: `work/{batch}/structural/keep_pass/{batch}-manta.vcf`
* Deal with chromosome capitalisation occurring from SnpEff
* Run BreakPointInspector (BPI) if it was disabled in bcbio
* __Output__: `work/{batch}/structural/maybe_bpi/{batch}-manta.vcf`

__Step 2: Filtering__

* Keep PASS variants (since BPI updates the FILTER column)
* For BND variants require paired reads support (PR) to be higher than split read support (SR)
* Keep all `INFO/SV_TOP_TIER <= 2` variants
* For `INFO/SV_TOP_TIER > 2` variants require split _or_ paired reads support of at least 5x
* For `INFO/SV_TOP_TIER > 2` variants with low allele frequency at any breakpoint (`BPI_AF[0 or 1] < 0.1`),
  require SR or PR support of at least 10x
* __Output__: `work/{batch}/structural/filt/{batch}-manta.vcf`

__Step 3: PURPLE and FFPE conditional__

* If the sample _is not_ FFPE:
  * Feed above filtered SVs to PURPLE, which outputs `purple.sv.vcf.gz` that contains rescued SVs
  * Prioritise variants (again)
  * Remove 'INFO/ANN' annotation
  * __Output__: `{batch}/structural/{batch}-manta.vcf.gz`
* If the sample _is_ FFPE:
  * Just copy `filtered` variants and don't do anything
    (i.e. we don't want the rescued SVs from PURPLE since they'll likely be heaps)
    (note that PURPLE will still get fed with the `filtered` SVs)
  * __Output__: `{batch}/structural/{batch}-manta.vcf.gz`

__Step 4: TSV final output__

* Input: `{batch}/structural/{batch}-manta.vcf.gz` VCF
* Output: `{batch}/structural/{batch}-manta.tsv` TSV


```{r manta_tsv_description}
sv_tsv_descr %>%
  dplyr::arrange(Column) %>%
  dplyr::mutate(Column = kableExtra::cell_spec(Column, bold = TRUE)) %>%
  knitr::kable(escape = FALSE, caption = "Description of Manta TSV columns") %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = FALSE, position = "left") %>%
  kableExtra::scroll_box(height = "250px")
```

__Prioritisation process__

1. Annotate with [SnpEff](http://snpeff.sourceforge.net/SnpEff_manual.html) based on Ensembl gene model
2. Subset annotations to [APPRIS principal transcripts](http://appris.bioinfo.cnio.es/#/)
3. Prioritize variants with [simple_sv_annotation](https://github.com/vladsaveliev/simple_sv_annotation)
   1(high)-2(moderate)-3(low)-4(no interest):
  * exon loss
     - on prioritisation gene list (1)
     - other (2)
  * gene_fusion
     - paired (hits two genes)
        - on list of known pairs (1) (curated by [HMF](https://resources.hartwigmedicalfoundation.nl))
        - one gene is a known promiscuous fusion gene (1) (curated by [HMF](https://resources.hartwigmedicalfoundation.nl))
        - on list of FusionCatcher known pairs (2)
        - other:
           - one or two genes on prioritisation gene list (2)
           - neither gene on prioritisation gene list (3)
     - unpaired (hits one gene)
         - on prioritisation gene list (2)
         - others (3)
  * upstream or downstream
     - on prioritisation gene list genes (2)  - e.g. one gene is got into
       control of another gene's promoter and get overexpressed (oncogene) or underexpressed (tsgene)
  * LoF or HIGH impact in a tumor suppressor
     - on prioritisation gene list (2)
     - other TS gene (3)
  * other (4)

* Use PURPLE copy number caller to infer more SV calls from copy number transitions (marked as 'PURPLE Inferred')

```{r effect_abbrev_tab}
gpgr::EFFECT_ABBREVIATIONS %>%
  tibble::enframe(value = "abbreviation") %>%
  dplyr::arrange(abbreviation) %>%
  dplyr::mutate(name = kableExtra::cell_spec(name, bold = TRUE)) %>%
  knitr::kable(escape = FALSE) %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = FALSE, position = "left") %>%
  kableExtra::scroll_box(height = "250px")
```

</details>

<details>
<summary>What do the SV tables show?</summary>

Structural variants often involve deletions/insertions encompassing large
genomic regions which can involve hundreds or even thousands of genes. The
annotations for these genes/transcripts are included in the original SV VCF,
but they are extremely hard to display and browse inside a HTML table, due to
their size.

Therefore, we first show a 'Map' of the SVs corresponding
to the main columns from the original SV VCF, but we don't show the
`INFO/SIMPLE_ANN` annotation column, which contains the
`Effect`, `Genes`, `Transcript`, and `Detail` values of a given SV. This makes
a bit more sense if you take a look at the `nann` Map column,
which shows the number of annotations corresponding to each VCF row. For example,
`nann = 500` would mean that this variant corresponds to 500 annotations.
These get shown in the next tables in a reshaped format, so that instead of
showing 500 annotations for a single row in a single cell, we split that over
multiple columns and rows. You can connect those tables to the Map by `vcfnum`.

Example SV with -only- 3 annotations:

```
SIMPLE_ANN=DEL|TFBS_ablation||MA0114&MA0139&MA0281|unprioritized|4,DEL|downstream_gene_variant|HFE2|ENST00000336751_exon_1/4|unprioritized|4,DEL|intergenic_region|TXNIP-HFE2|ENSG00000265972-ENSG00000168509|unprioritized|4
```

Reshaped:

```
svtype | effect                  | genes      | transcript                      | detail        | tier
DEL    | TFBS_ablation           |            | MA0114&MA0139&MA0281            | unprioritized | 4
DEL    | downstream_gene_variant | HFE2       | ENST00000336751_exon_1/4        | unprioritized | 4
DEL    | intergenic_region       | TXNIP-HFE2 | ENSG00000265972-ENSG00000168509 | unprioritized | 4
```

- The Map is sorted by `TierTop` then `vcfnum`:
  - `TierTop` is the top tier of all annotations for a given variant.
  - `vcfnum` is the variant row number in the umccrised VCF.

</details>



### Summary {.tabset .tabset-fade}

#### Plots

```{r plot_bnd_sr_pr_tot_lines, fig.width=12, fig.height=12, out.width="90%"}
p1 <- gpgr:::plot_bnd_sr_pr_tot_lines(sv_unmelted)
p2 <- gpgr::plot_bnd_sr_pr_tot_hist(sv_unmelted) + ggplot2::theme(legend.position = "none")
((p1$p_all | p2) / p1$p_tier)
```

#### Counts

```{r sv_summary, eval=!no_sv_found}
d <-
  list(unmelted = sv_unmelted %>% dplyr::select(Tier = TierTop, Type),
       melted = sv_all %>% dplyr::select(Tier, Type)) %>%
  dplyr::bind_rows(.id = "group") %>%
  dplyr::mutate(group = factor(group, levels = c("unmelted", "melted"))) %>%
  dplyr::group_by(group) %>%
  dplyr::count(Tier, Type) %>%
  tidyr::pivot_wider(names_from = Type, values_from = n) %>%
  dplyr::ungroup() %>%
  dplyr::rowwise() %>%
  dplyr::mutate(tot = sum(dplyr::c_across(!(c(group, Tier))), na.rm = TRUE))

d %>%
  gt::gt(
    groupname_col = "group",
    rowname_col = "Tier") %>%
  gt::tab_header(
    title = "SV type counts by tier",
    subtitle = "(TopTier used for melted variants)"
  ) %>%
  gt::tab_stubhead(label = "Tier") %>%
  gt::summary_rows(groups = TRUE,
                   fns = list(tot = ~sum(., na.rm = TRUE)),
                   drop_trailing_zeros = TRUE) %>%
  gt::fmt_missing(columns = dplyr::everything()) %>%
  gt::tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_stub(rows = TRUE)
  ) %>%
  gt::cols_align("right") %>%
  gt::tab_options(table.align = "left")
```

```{r, results='asis'}
blank_lines(1)
```

### __SV Map__ {#sv-unmelted}

```{r svtab_raw, eval=!no_sv_found}
svtab_raw <- sv_unmelted %>%
  dplyr::select(-annotation) %>%
  dplyr::arrange(TierTop, vcfnum)

svtab_rawdt <- svtab_raw %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(
                  scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = FALSE, keys = TRUE,
                  buttons = c('csv', 'excel'), dom = 'Blfrtip'))
```

```{r svtab_raw_details, eval=!no_sv_found}
details::details(sv_detail_table(svtab_raw), lang = NULL, summary = "Column Description")
svtab_rawdt
```

```{r, results='asis'}
blank_lines(2)
```

### __Translocations (BNDs)__ {.tabset .tabset-fade #translocations}

```{r svtab_BND, eval=!no_sv_found}
sv_BND <- sv_all %>%
  dplyr::filter(Type == "BND") %>%
  dplyr::mutate(nrow = dplyr::row_number(),
                nrow = sprintf(glue::glue("%0{nchar(nrow(.))}d"), nrow)) %>%
  dplyr::select(nrow, dplyr::everything())


sv_BND_main <- sv_BND %>%
  dplyr::select(nrow, vcfnum, `Tier (Top)`, Start, End,
                BND_ID, BND_mate,
                Genes, Effect, Detail, SR_alt, PR_alt, SR_PR_sum, Ploidy, AF_PURPLE)

sv_BND_other <- sv_BND %>%
  dplyr::select(nrow, AF_BPI, CNC, CN, SR_PR_ref, SScore, ntrx, Transcript)

sv_BND_purple <- sv_all %>%
  dplyr::filter(Type %in% c("PURPLE_inf")) %>%
  dplyr::select(`Tier (Top)`, Start, Effect, Detail, Ploidy, CN, CNC)

gpgr::write_tsvjsongz(
  dplyr::bind_cols(sv_BND_main, sv_BND_other %>% dplyr::select(-nrow)),
  glue("sv/{bnm}-03_sv_BND_main"), result_outdir)
gpgr::write_tsvjsongz(sv_BND_purple, glue("sv/{bnm}-04_sv_BND_purpleinf"), result_outdir)

sv_BND_maindt <- sv_BND_main %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(
                  scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = FALSE, keys = TRUE,
                  buttons = c('csv', 'excel'), dom = 'Blfrtip'))

sv_BND_otherdt <- sv_BND_other %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(
                  scroller = TRUE, scrollY = 400, scrollX = TRUE, keys = TRUE, autoWidth = FALSE,
                  buttons = c('csv', 'excel'), dom = 'Blfrtip'))

sv_BND_purpledt <- sv_BND_purple %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(
                  scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = TRUE,
                  buttons = c('csv', 'excel'),
                  dom = 'Blfrtip'))
```

#### Main Columns

```{r sv_BND_main, eval=!no_sv_found}
details::details(sv_detail_table(sv_BND_main), lang = NULL, summary = "Column Description")
sv_BND_maindt
```

```{r, results='asis'}
blank_lines(2)
```

#### Other Columns

```{r sv_BND_otherdt, eval=!no_sv_found}
details::details(sv_detail_table(sv_BND_other), lang = NULL, summary = "Column Description")
sv_BND_otherdt
```

#### PURPLE Inferred

```{r sv_BND_purple, eval=!no_sv_found}
details::details(sv_detail_table(sv_BND_purple), lang = NULL, summary = "Column Description")
sv_BND_purpledt
```

### __DEL/DUP/INS__ {.tabset .tabset-fade #deldupins}

```{r svtab_noBND, eval=!no_sv_found}
sv_noBND <- sv_all %>%
  dplyr::filter(!Type %in% c("BND", "PURPLE_inf")) %>%
  dplyr::mutate(nrow = dplyr::row_number(),
                nrow = sprintf(glue::glue("%0{nchar(nrow(.))}d"), nrow),
                Genes_original = Genes,
                Transcript_original = Transcript)

max_genes <- 2
max_transcripts <- 2

sv_noBND_main <- sv_noBND %>%
  dplyr::mutate(Genes = ifelse(ngen > max_genes,
                               glue::glue("Many Genes ({ngen})"),
                               Genes),
                Transcript = ifelse(ntrx > max_transcripts,
                                    glue::glue("Many Transcripts ({ntrx})"),
                                    Transcript)) %>%
  dplyr::select(nrow, vcfnum, `Tier (Top)`, Type, Start, End, Effect,
                Genes, Transcript, Detail, SR_alt, PR_alt, SR_PR_sum, AF_PURPLE)

gpgr::write_tsvjsongz(sv_noBND_main, glue("sv/{bnm}-05_sv_noBND_main"), result_outdir)

sv_noBND_other <- sv_noBND %>%
  dplyr::select(vcfnum, Ploidy, AF_BPI, CNC, CN, SR_PR_ref, SScore) %>%
  dplyr::distinct()

gpgr::write_tsvjsongz(sv_noBND_other, glue("sv/{bnm}-06_sv_noBND_other"), result_outdir)

sv_noBND_manygenes <- sv_noBND %>%
  dplyr::filter(ngen > max_genes) %>%
  dplyr::select(nrow, vcfnum, `Tier (Top)`, Type, Start, End,
                Effect, ngen, Genes = Genes_original)

gpgr::write_tsvjsongz(sv_noBND_manygenes, glue("sv/{bnm}-07_sv_noBND_manygenes"), result_outdir)

sv_noBND_manytx <- sv_noBND %>%
  dplyr::filter(ntrx > max_transcripts) %>%
  dplyr::select(nrow, vcfnum, `Tier (Top)`, Type, Start, End,
                Effect, ntrx, Transcript = Transcript_original)

gpgr::write_tsvjsongz(sv_noBND_manytx, glue("sv/{bnm}-08_sv_noBND_manytranscripts"), result_outdir)

sv_noBND_maindt <- sv_noBND_main %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Buttons"),
                options = list(
                  pageLength = 20,
                  autoWidth = FALSE,
                  buttons = c('csv', 'excel'), dom = 'Blfrtip'))

sv_noBND_otherdt <- sv_noBND_other %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Buttons"),
                options = list(
                  pageLength = 20,
                  autoWidth = FALSE,
                  buttons = c('csv', 'excel'),
                  dom = 'Blfrtip'))

sv_noBND_manygenesdt <- sv_noBND_manygenes %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Buttons", "KeyTable"),
                options = list(
                  pageLength = 10,
                  autoWidth = FALSE, keys = TRUE,
                  buttons = c('csv', 'excel'),
                  dom = 'Blfrtip'))

sv_noBND_manytxdt <- sv_noBND_manytx %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Buttons", "KeyTable"),
                options = list(
                  pageLength = 10,
                  autoWidth = FALSE, keys = TRUE,
                  buttons = c('csv', 'excel'),
                  dom = 'Blfrtip'))
```

#### Main Columns

```{r sv_noBND_main, eval=!no_sv_found}
details::details(sv_detail_table(sv_noBND_main), lang = NULL, summary = "Column Description")
sv_noBND_maindt
```

```{r, results='asis'}
blank_lines(2)
```

#### Other Columns

```{r sv_noBND2_other, eval=!no_sv_found}
details::details(sv_detail_table(sv_noBND_other), lang = NULL, summary = "Column Description")
sv_noBND_otherdt
```

#### Many Genes

```{r sv_noBND_manygenes, eval=!no_sv_found}
details::details(sv_detail_table(sv_noBND_manygenes), lang = NULL, summary = "Column Description")
sv_noBND_manygenesdt
```

#### Many Transcripts

```{r sv_noBND_manytx, eval=!no_sv_found}
details::details(sv_detail_table(sv_noBND_manytx), lang = NULL, summary = "Column Description")
sv_noBND_manytxdt
```

## __Copy Number Variants__
The purity and ploidy estimator
[PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator)
is used to generate a copy number profile for the somatic sample.

```{r, results='asis'}
blank_lines(1)
```

### UMCCR __Gene Somatic__ CNV Calls {#cnv-gene}

<details>
<summary>Description</summary>

PURPLE copy number alterations in the UMCCR Cancer Gene panel (~1,200 genes) - description
is from <https://github.com/hartwigmedical/hmftools/blob/master/purity-ploidy-estimator/README.md#gene-copy-number-file>

```{r purple_gene_cnv_description}
purple_cnv_som_gene$descr %>%
  dplyr::mutate(
    Column = kableExtra::cell_spec(Column, bold = TRUE)) %>%
  knitr::kable(escape = FALSE) %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = FALSE, position = "left") %>%
  kableExtra::scroll_box(height = "200px")
```

</details>

```{r purple_gene_cnv_tab}
purple_cnv_som_gene$tab %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = TRUE, keys = TRUE,
                               buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
  DT::formatCurrency(~ start + end, currency = "", interval = 3, mark = ",", digits = 0) %>%
  DT::formatRound(~ minCN + maxCN, digits = 1)
```

```{r, results='asis'}
blank_lines(2)
```

### Genome-wide __Somatic__ CNV Segments {#cnv-segs}

<details>
<summary>Description</summary>

PURPLE outputs a file with the copy number profile of all contiguous segments
of the tumor sample:

PURPLE copy number profile of all (contiguous) segments of the tumor sample - description
is from <https://github.com/hartwigmedical/hmftools/blob/master/purity-ploidy-estimator/README.md#copy-number-file>


```{r purple_seg_description}
purple_cnv_som$descr %>%
  dplyr::mutate(
    Column = kableExtra::cell_spec(Column, bold = TRUE)) %>%
  knitr::kable(escape = FALSE) %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = FALSE, position = "left") %>%
  kableExtra::scroll_box(height = "200px")
```

</details>

```{r purple_cnv_som_tab}
purple_cnv_som$tab %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = TRUE, keys = TRUE,
                               buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
  DT::formatCurrency(~ Start + End, currency = "", interval = 3, mark = ",", digits = 0)
```

```{r, results='asis'}
blank_lines(2)
```

### Genome-wide __Germline__ CNV Segments

```{r purple_cnv_germ_tab}
purple_cnv_germ$tab %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                class = "cell-border display compact",
                rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = TRUE, keys = TRUE,
                               buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
  DT::formatCurrency(~ Start + End, currency = "", interval = 3, mark = ",", digits = 0)
```

```{r, results='asis'}
blank_lines(2)
```

### __PURPLE Charts__ {.tabset .tabset-fade #purple-charts}
PURPLE generates charts for summarising tumor sample characteristics.
Description is from the [PURPLE docs](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator#charts).

#### Purity/ploidy
The following 'sunrise' chart shows the range of scores of all examined solutions of
purity and ploidy. Crosshairs identify the best purity / ploidy solution.

```{r purple_plot_purityrange, out.width="40%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.purity.range.png')))
```

```{r, results='asis'}
blank_lines(2)
```

#### Copy number / Minor allele ploidy
The following figures show the AMBER BAF count weighted distribution of
copy number and minor allele ploidy throughout the fitted segments.
Copy numbers are broken down by colour into their respective minor
allele ploidy (MAP) while the minor allele ploidy figure is broken
down by copy number.

```{r purple_plot_copynumber, out.width="40%"}
knitr::include_graphics(c(file.path(img_dir, paste0(bnm, '.copynumber.png')),
                        file.path(img_dir, paste0(bnm, '.map.png'))))
```

#### Rainfall
If a somatic variant VCF has been supplied, a figure will be produced
showing the somatic variant ploidy broken down by copy number.

```{r purple_plot_somatic, out.width="40%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.somatic.png')))
```

#### Clonality
The following diagram illustrates the clonality model of a typical sample.

The top figure shows the histogram of somatic ploidy for all SNVs and INDELs in blue.
Superimposed are peaks in different colours fitted from the sample as described in the
docs while the black line shows the overall fitted ploidy distribution. Red filled
peaks are below the 0.85 subclonal threshold.

We can determine the likelihood of a variant being subclonal at
any given ploidy as shown in the bottom half of the figure.

```{r purple_plot_somaticclonality, out.width="50%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.somatic.clonality.png')))
```

#### Segment
The contribution of each fitted segment to the final score of the best fit is shown in
the following figure. Each segment is divided into its major and minor allele ploidy.
The area of each circle shows the weight (AMBER baf count) of each segment.

```{r purple_plot_segment, out.width="40%"}
knitr::include_graphics(file.path(img_dir, paste0(bnm, '.segment.png')))
```

## __Oncoviruses__ {.tabset .tabset-fade #oncoviruses}

Oncoviruses and their integration sites. Viral sequences are obtained from the
<a href="https://gdc.cancer.gov/about-data/data-harmonization-and-generation/gdc-reference-files">GDC database</a>.
Host genes are reported if the integration site falls on a gene or at least before 100kbp of the gene start.

```{r oncoviruses_table}
present_viruses <- params$oncoviral_present_viruses
breakpoints_tsv <- params$oncoviral_breakpoints_tsv

if (!is.na(breakpoints_tsv) && breakpoints_tsv != "" && file.exists(breakpoints_tsv)) {
  breakpoints <- readr::read_tsv(breakpoints_tsv, col_names = T, col_types = "cciicicccc")
  breakpoints %>%
    dplyr::mutate(Coord = ifelse(is.na(end), start, str_c(start, "-", end))) %>%
    dplyr::select(Contig = contig, Coord, `Read support` = PAIR_COUNT,
                  `Disrupted genes` = DisruptedGenes, `Upstream genes` = UpstreamGenes,
                  `SV type` = svtype, ID, MATEID) %>%
    DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                  class = "cell-border display compact",
                  rownames = FALSE, extensions = c("Scroller", "Buttons", "KeyTable"),
                  options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, autoWidth = TRUE, keys = TRUE,
                                 buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
    DT::formatCurrency(~ Coord, currency = "", interval = 3, mark = ",", digits = 0)
} else {
  if (!is.na(present_viruses) && present_viruses != "" && file.exists(present_viruses)) {
    viruses <- readr::read_file(present_viruses)
    if (str_length(viruses) > 0) {
      cat(str_c("Detected significant traces of content of the following viruses: ",
                viruses,
                ", however no evidence of viral integration into the host genome is observed."))
    } else {
      cat("No oncoviral content detected in this sample.")
    }
  } else {
    cat("Oncoviral detection was disabled in the umccrise run with `-E oncoviruses`.")
  }
}
```

```{r, results='asis'}
blank_lines(1)
```

## __Addendum__ {.tabset .tabset-fade #addendum}

<a href="#top">Back to top</a>

### Conda Pkgs Main

```{r conda_list_main}
conda_pkgs <-
  readr::read_table2(params$conda_list,
                     col_names = c("env", "name", "version", "build", "channel"),
                     col_types = "ccccc") %>%
  dplyr::mutate(channel = ifelse(is.na(channel), "MISSING", channel),
                env = sub("env", "umccrise", env),
                env = sub("^umccrise_", "", env)) %>%
  dplyr::arrange(name) %>%
  dplyr::group_by(name, version, build, channel) %>%
  dplyr::summarise(envs = paste(env, collapse = ", "), .groups = "drop_last") %>%
  dplyr::ungroup()

# main pkgs
tibble::tibble(
  name = c(
    "umccrise", "r-gpgr", "r-base", "pcgr", "cpsr", "cacao",
    "hmftools-purple", "hmftools-amber", "hmftools-cobalt", "hmftools-sage",
    "gridss", "hmftools-linx",
    "multiqc", "multiqc-bcbio", "reference-data",
    "bed_annotation", "vcf-stuff", "snakemake",
    "samtools", "bcftools", "htslib", "ngs_utils", "python", "pandoc"
  )
) %>%
  dplyr::left_join(conda_pkgs, by = "name") %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = TRUE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::scroll_box(height = "300px")
```

### Report Inputs

```{r report_inputs}
report_inputs <- dplyr::tibble(key = names(params), value = unlist(params))
gpgr::write_tsvjsongz(report_inputs, glue("{bnm}-report_inputs"), result_outdir)

report_inputs %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_paper(c("hover", "striped"), full_width = FALSE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::scroll_box(height = "200px")
```

### Conda Pkgs All

```{r conda_list_all}
conda_pkgs %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                rownames = FALSE, extensions = c("Scroller", "Buttons"),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 400,
                               buttons = c('csv'), dom = 'Bfrtip'))
```
